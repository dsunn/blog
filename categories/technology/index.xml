<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on Whatever blog</title>
    <link>https://dsunn.github.io/blog/categories/technology/</link>
    <description>Recent content in Technology on Whatever blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Feb 2026 18:15:00 +0800</lastBuildDate><atom:link href="https://dsunn.github.io/blog/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AI Dial-Up Era: The Last Window to Truly Understand AI</title>
      <link>https://dsunn.github.io/blog/post/ai-dialup-window/</link>
      <pubDate>Thu, 12 Feb 2026 18:15:00 +0800</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/ai-dialup-window/</guid>
      <description>
        
          
            &lt;h1 id=&#34;ai-dial-up-era-the-last-window-to-truly-understand-ai&#34;&gt;AI Dial-Up Era: The Last Window to Truly Understand AI&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Inspired by Alex Prompter. The &amp;ldquo;ease of use&amp;rdquo; in AI tools is quietly closing the window to truly understand the technology.&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;the-expensive-excuse&#34;&gt;The Expensive Excuse&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;I will learn AI when it matures.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;This sounds reasonable. This is also the most expensive sentence you can say in 2026.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;what-the-internet-taught-us&#34;&gt;What the Internet Taught Us&lt;/h2&gt;
&lt;p&gt;In 1993, getting online meant configuring dial-up modems, navigating BBS boards, and understanding HTTP/DNS/FTP. Those people became the founders and CTOs of Yahoo, Amazon, and Google.&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>OpenClaw与VirusTotal合作：AI代理安全的思考</title>
      <link>https://dsunn.github.io/blog/post/openclaw/</link>
      <pubDate>Tue, 10 Feb 2026 15:00:00 +0800</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/openclaw/</guid>
      <description>
        
          
            &lt;p&gt;modified: 2026-02-10T16:25&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天，OpenClaw宣布与全球领先的威胁情报平台VirusTotal合作，为ClawHub技能市场带来安全扫描功能。这不仅仅是技术集成，更是对AI代理安全范式的深度思考。&lt;/p&gt;
&lt;h2 id=&#34;传统安全模型的困境&#34;&gt;传统安全模型的困境&lt;/h2&gt;
&lt;p&gt;过去20年，安全模型建立在锁定设备和应用的基础上——在进程间通信设置边界、隔离互联网与本地、隔离不受信任的代码。这些原则依然重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但AI代理代表了根本性的转变。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与传统软件不同，AI代理解释自然语言并做出关于行动的决策。它们模糊了用户意图与机器执行之间的界限。它们可以通过语言本身被操纵。&lt;/p&gt;
&lt;h2 id=&#34;技能的权力与风险&#34;&gt;技能的权力与风险&lt;/h2&gt;
&lt;p&gt;OpenClaw技能是强大的。它们扩展了AI代理的能力——从控制智能家居设备到管理财务再到自动化工作流。但这种力量伴随着风险。&lt;/p&gt;
&lt;p&gt;技能是在代理上下文中运行的代码，有权限访问你的工具和数据。恶意技能可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泄露敏感信息&lt;/li&gt;
&lt;li&gt;执行未授权命令&lt;/li&gt;
&lt;li&gt;以你的名义发送消息&lt;/li&gt;
&lt;li&gt;下载并运行外部负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着OpenClaw生态系统的增长，攻击面也在扩大。我们已经看到恶意行为者试图利用AI代理平台的案例。&lt;/p&gt;
&lt;h2 id=&#34;集成是如何工作的&#34;&gt;集成是如何工作的&lt;/h2&gt;
&lt;p&gt;当技能发布到ClawHub时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确定性打包&lt;/strong&gt; - 技能文件被捆绑成ZIP，包含元数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希计算&lt;/strong&gt; - 为整个包计算SHA-256，创建唯一指纹&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VirusTotal查询&lt;/strong&gt; - 哈希值与VT数据库比对&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上传与分析&lt;/strong&gt; - 如果没有匹配，通过v3 API上传进行扫描&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码洞察&lt;/strong&gt; - VirusTotal的LLM-powered Code Insight对整个技能包进行安全分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动审批&lt;/strong&gt; - &amp;ldquo;良性&amp;rdquo; verdict的技能自动批准，恶意技能即时阻止&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每日重新扫描&lt;/strong&gt; - 检测已清理技能是否变恶意&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;这不是什么&#34;&gt;这不是什么&lt;/h2&gt;
&lt;p&gt;让我们明确：&lt;strong&gt;这不是银弹。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VirusTotal扫描无法捕获一切。使用自然语言指导代理做坏事的技能不会触发病毒签名。精心设计的提示注入载荷不会出现在威胁数据库中。&lt;/p&gt;
&lt;p&gt;但这确实提供了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已知恶意软件的检测&lt;/li&gt;
&lt;li&gt;行为分析 - Code Insight识别可疑模式&lt;/li&gt;
&lt;li&gt;供应链可见性 - 捕获受损依赖和嵌入的可执行文件&lt;/li&gt;
&lt;li&gt;意图信号 - 我们正在投资安全，这是众多层次中的第一层&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;更广阔的图景&#34;&gt;更广阔的图景&lt;/h2&gt;
&lt;p&gt;这项合作是OpenClaw更广泛安全计划的一部分。接下来将发布：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenClaw生态系统的综合威胁模型&lt;/li&gt;
&lt;li&gt;跟踪防御工程目标的公共安全路线图&lt;/li&gt;
&lt;li&gt;覆盖整个代码库的安全审计详情&lt;/li&gt;
&lt;li&gt;带有定义SLA的正式安全报告流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;AI代理应该拥有真正的安全进程。我们正在建立它们。&lt;/p&gt;
&lt;p&gt;安全是纵深防御。这是一层。还有更多层正在到来。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;本文基于OpenClaw官方博客 &lt;a href=&#34;https://openclaw.ai/blog/virustotal-partnership&#34;&gt;VirusTotal Partnership&lt;/a&gt; 深度思考而成&lt;/em&gt;&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>John Carmack的脑洞：用光纤替代DRAM做缓存？</title>
      <link>https://dsunn.github.io/blog/post/fiber-cache-carmack/</link>
      <pubDate>Tue, 10 Feb 2026 00:00:00 +0000</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/fiber-cache-carmack/</guid>
      <description>
        
          
            &lt;h1 id=&#34;john-carmack的脑洞用光纤替代dram做缓存&#34;&gt;John Carmack的脑洞：用光纤替代DRAM做缓存？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;我不是天才，只是很努力地思考问题。&amp;rdquo; —— John Carmack&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;传奇程序员、Oculus联合创始人John Carmack最近又提出了一个颠覆性的硬件设想：&lt;strong&gt;用长距离光纤替代DRAM作为AI的L2缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这听起来像是科幻小说，但它背后有严谨的数学支撑。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;为什么dram不够用了&#34;&gt;为什么DRAM不够用了？&lt;/h2&gt;
&lt;p&gt;现代AI模型（尤其是大语言模型）的权重（weights）越来越大：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;模型&lt;/th&gt;
          &lt;th&gt;参数大小&lt;/th&gt;
          &lt;th&gt;需要多少显存？&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;GPT-3&lt;/td&gt;
          &lt;td&gt;1750亿&lt;/td&gt;
          &lt;td&gt;~350GB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;GPT-4&lt;/td&gt;
          &lt;td&gt;估计万亿级&lt;/td&gt;
          &lt;td&gt;TB级别&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：我们不可能把所有权重都塞进GPU显存。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;carmack的解法让数据流动起来&#34;&gt;Carmack的解法：让数据&amp;quot;流动&amp;quot;起来&lt;/h2&gt;
&lt;h3 id=&#34;核心洞察&#34;&gt;核心洞察&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;光在光纤里传输是需要时间的&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;光在玻璃中的速度：约20万公里/秒&lt;/li&gt;
&lt;li&gt;100km光纤 = 0.5毫秒延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果带宽足够大，这段时间内&amp;quot;在途数据&amp;quot;本身就可以当缓存用。&lt;/p&gt;
&lt;h3 id=&#34;数学计算&#34;&gt;数学计算&lt;/h3&gt;
&lt;p&gt;已知光纤通信的最新进展：&lt;strong&gt;256 Tb/s&lt;/strong&gt;（太比特每秒）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;256 Tb/s × 0.5ms = 256 × 10^12 × 0.5 × 10^-3
                = 128 Tb
                = 16 GB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;：100km光纤能同时&amp;quot;容纳&amp;quot;约16GB数据在传输中！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;这个方案适合什么场景&#34;&gt;这个方案适合什么场景？&lt;/h2&gt;
&lt;h3 id=&#34;-适合流式ai推理&#34;&gt;✅ 适合：流式AI推理&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────────────────┐
│  光纤 ──数据流──► GPU ──边算边读──► 输出   │
└─────────────────────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;边从光纤读取权重，边做推理计算&lt;/li&gt;
&lt;li&gt;不需要把整个模型加载到显存&lt;/li&gt;
&lt;li&gt;数据像流水线一样&amp;quot;流&amp;quot;过计算单元&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-不适合&#34;&gt;❌ 不适合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;需要随机访问的场合&lt;/li&gt;
&lt;li&gt;交互式低延迟应用（如游戏）&lt;/li&gt;
&lt;li&gt;小数据量的高频查询&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;技术对比&#34;&gt;技术对比&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;光纤延迟线&lt;/th&gt;
          &lt;th&gt;传统DRAM&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;带宽&lt;/td&gt;
          &lt;td&gt;极高 (256 Tb/s已实现)&lt;/td&gt;
          &lt;td&gt;中等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;延迟&lt;/td&gt;
          &lt;td&gt;固定（取决于光纤长度）&lt;/td&gt;
          &lt;td&gt;很低&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;容量&lt;/td&gt;
          &lt;td&gt;取决于长度×带宽&lt;/td&gt;
          &lt;td&gt;受限于物理密度&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;访问模式&lt;/td&gt;
          &lt;td&gt;顺序流式&lt;/td&gt;
          &lt;td&gt;随机访问&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;我的思考&#34;&gt;我的思考&lt;/h2&gt;
&lt;p&gt;Carmack这个想法让我联想到计算机体系结构的几个经典概念：&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>Vyos</title>
      <link>https://dsunn.github.io/blog/post/vyos/</link>
      <pubDate>Sat, 22 Mar 2025 14:18:21 +0800</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/vyos/</guid>
      <description>
        
          
            &lt;p&gt;modified: 2025-06-13T15:08&lt;/p&gt;
&lt;p&gt;vyos的命令行界面是基于shell的，没有图形界面, 但是可以用tab自动补全.
本文的vyos命令是基于vyos的vyos-rolling-nightly-builds的1.5.x版本.&lt;/p&gt;
&lt;p&gt;pve安装vyos:
下载nightly-build: &lt;a href=&#34;https://github.com/vyos/vyos-nightly-build/releases&#34;&gt;https://github.com/vyos/vyos-nightly-build/releases&lt;/a&gt;
pve的虚拟机设置和安装(略), 建议内存2G, 磁盘10G或更大, 因为vyos可以运行容器, vyos用podman管理容器.&lt;/p&gt;
&lt;p&gt;vm运行后, 用vyos:vyos登录. 用命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;install image
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装vyos.&lt;/p&gt;
&lt;p&gt;设置ssh登录:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set service ssh port &amp;#39;22&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建用户dave:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set system login user dave full-name dave
set system login user dave authentication plaintext-password &amp;#39;your-password&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;建议ssh密钥登录:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set system login user dave authentication public-keys dave@laptop key &amp;#39;your-public-key&amp;#39;
set system login user dave authentication public-keys dave@laptop type &amp;#39;ssh-rsa&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;禁用默认的vyos用户:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set system login user vyos disable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置系统的hostname:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set system host-name &amp;#39;vyos&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置时区:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set system time-zone &amp;#39;Asia/Shanghai&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置ntp:&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>All about dns</title>
      <link>https://dsunn.github.io/blog/post/all_about_dns/</link>
      <pubDate>Tue, 05 Mar 2024 08:00:07 -0500</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/all_about_dns/</guid>
      <description>
        
          
            &lt;p&gt;谈谈我的dns在一些特殊的网络架构中的思路&amp;hellip;
目的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;走节点的连接, 其dns请求不发到国内的dns服务器&lt;/li&gt;
&lt;li&gt;减少不必要的dns请求&lt;/li&gt;
&lt;li&gt;尽量避免所谓的dns leak&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;我的内部网络:&lt;/p&gt;
&lt;p&gt;主路由 ros, 旁路网关 clash on debain, mosdns server, 交换机, 及各种终端;
其中clash所在的debian, 网关为ros, 其他设备的网关为clash所在的debian;
内网到内网的通信基本上会经交换机转发抵达.&lt;/p&gt;
&lt;p&gt;ros:&lt;/p&gt;
&lt;p&gt;ros上开启dns服务, 上游为ISP的ipv4和ipv6服务器, 开启Allow Remote Requests, (这条开启是仅仅让mosdns访问的, 后面详解)
ros通过dhcp_server通知各终端把dns和网关都指向clash及clash_dns, 除clash自己.&lt;/p&gt;
&lt;p&gt;clash:&lt;/p&gt;
&lt;p&gt;clash开启dns服务(我用的fake_ip, 当然不用fake_ip也行, 不影响前述目的), clash_dns的唯一上游, 是mosdns; 同时, clash 的 fallback_dns关闭&lt;/p&gt;
&lt;p&gt;mosdns:&lt;/p&gt;
&lt;p&gt;mosdns按direct-list(即cn_sites)的域名进行分流, 命中该list的, 请求发到上游ros_dns, ros_dns会向它的上游, 也就是向各ISP_dns请求; 而没有命中该list的, 也就是走节点的, mosdns把请求发给上游8.8.8.8(建议dot/doh); mosdns同样不采用fallback_dns的策略.&lt;/p&gt;
&lt;p&gt;我们来看一下数据包的路径: mosdns发给ros的请求, 因为都是内网设备, 将直接由交换机转发, 而不经过mosdns的网关, 即clash所在的debian; 而mosdns发给8.8.8.8(我是用dot)的请求, 会按网关要求, 发给clash所在的debian, debian会转发给clash, 由clash加密封装后, 按规则走指定的节点. 当然clash最后也是通过debian的网关, 即ros, 再发到节点.&lt;/p&gt;
&lt;p&gt;各终端设备:&lt;/p&gt;
&lt;p&gt;终端设备的dns, 是近观ros dhcp_server的通知, 设置为clash_dns, 而clash_dns_server, 我是设置为fake_ip模式, 当然也可以不设置为fake_ip模式, 后面我会说fake_ip模式的好处.&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>cloudflare ddns的routeros脚本</title>
      <link>https://dsunn.github.io/blog/post/mikrotik_cf_ddns/</link>
      <pubDate>Tue, 05 Mar 2024 07:33:25 -0500</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/mikrotik_cf_ddns/</guid>
      <description>
        
          
            &lt;p&gt;在参考了j大佬的&lt;a href=&#34;https://www.digs.eu.org/2024/01/04/ROS%20cloudflare%20DDNS%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC/&#34;&gt;博客&lt;/a&gt;和这位作者的&lt;a href=&#34;https://gist.githubusercontent.com/kolobus/18680f8fb01ce3003cb9a3f82c9d30e1/raw/cf8ecd84fc0e5dccb7298422c7d8c40410c345a3/cf-ddns.rsc&#34;&gt;脚本&lt;/a&gt;的脚本后, 魔改的.&lt;/p&gt;
&lt;p&gt;适用在cloudflare上更新ipv4和ipv6的动态ip; 和原作者不同的是, 我的脚本是直接从ros接口上取相应ip, 其实我这脚本是放在ppp profile-on up-script中, 在拨号完成后执行一次, 而不是定时反复执行, 故相应修改了代码.&lt;/p&gt;
&lt;p&gt;token, zone_id, record_id等请先行获取, 获取方法在前述j大佬博客中有所提及.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Cloudflare Dynamic DNS update script
# Required policy: read, write, test, policy
# Add this script to scheduler
# Install DigiCert root CA or disable check-certificate
# Modified from https://gist.github.com/kolobus/18680f8fb01ce3003cb9a3f82c9d30e1
# Configuration ---------------------------------------------------------------------

:local TOKEN &amp;#34;&amp;#34;

:local ZONEIDv6 &amp;#34;&amp;#34;
:local RECORDIDv6 &amp;#34;&amp;#34;
:local RECORDNAMEv6 &amp;#34;&amp;#34;
:local IP6NEW

:local ZONEIDv4 &amp;#34;&amp;#34;
:local RECORDIDv4 &amp;#34;&amp;#34;
:local RECORDNAMEv4 &amp;#34;&amp;#34;
:local IP4NEW

:local WANIF &amp;#34;&amp;#34;

#------------------------------------------------------------------------------------




:if ([/interface get $WANIF value-name=running]) do={

    # IPv6 check

    :local &amp;#34;IP6NEW&amp;#34; [/ipv6/address get [:pick [find dynamic global interface=$WANIF] 0 ] address]
    :set &amp;#34;IP6NEW&amp;#34; [:pick $&amp;#34;IP6NEW&amp;#34; 0 [:find $&amp;#34;IP6NEW&amp;#34; &amp;#34;/&amp;#34;]]

        :local url &amp;#34;https://api.cloudflare.com/client/v4/zones/$ZONEIDv6/dns_records/$RECORDIDv6/&amp;#34;

        :local cfapi [/tool fetch http-method=put mode=https url=$url check-certificate=no output=user as-value \
            http-header-field=&amp;#34;Authorization: Bearer $TOKEN&amp;#34; \
            http-data=&amp;#34;{\&amp;#34;type\&amp;#34;:\&amp;#34;AAAA\&amp;#34;,\&amp;#34;name\&amp;#34;:\&amp;#34;$RECORDNAMEv6\&amp;#34;,\&amp;#34;content\&amp;#34;:\&amp;#34;$IP6NEW\&amp;#34;,\&amp;#34;ttl\&amp;#34;:120,\&amp;#34;proxied\&amp;#34;:false}&amp;#34;]

        :log info &amp;#34;CF-DDNS: $RECORDNAMEv6 is now $IP6NEW&amp;#34;


   # IPv4 check

    :local ipaddr [/ip address get [/ip address find interface=$WANIF] address]
    :set IP4NEW [:pick $ipaddr 0 ([len $ipaddr] -3)]

        :local url &amp;#34;https://api.cloudflare.com/client/v4/zones/$ZONEIDv4/dns_records/$RECORDIDv4/&amp;#34;

        :local cfapi [/tool fetch http-method=put mode=https url=$url check-certificate=no output=user as-value \
            http-header-field=&amp;#34;Authorization: Bearer $TOKEN&amp;#34; \
            http-data=&amp;#34;{\&amp;#34;type\&amp;#34;:\&amp;#34;A\&amp;#34;,\&amp;#34;name\&amp;#34;:\&amp;#34;$RECORDNAMEv4\&amp;#34;,\&amp;#34;content\&amp;#34;:\&amp;#34;$IP4NEW\&amp;#34;,\&amp;#34;ttl\&amp;#34;:120,\&amp;#34;proxied\&amp;#34;:false}&amp;#34;]

        :log info &amp;#34;CF-DDNS: $RECORDNAMEv4 is now $IP4NEW&amp;#34;


} else={

    :log info &amp;#34;CF-DDNS: $WANIF is not currently running, quitting&amp;#34;

}
&lt;/code&gt;&lt;/pre&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>debian搭建clash的透明代理(Tproxy)(nftables转发)</title>
      <link>https://dsunn.github.io/blog/post/clash_nft/</link>
      <pubDate>Tue, 19 Sep 2023 20:47:03 -0400</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/clash_nft/</guid>
      <description>
        
          
            &lt;p&gt;ref debian搭建clash的透明代理(Tproxy)(iptables转发)&lt;a href=&#34;https://dsunn.github.io/blog/post/clash/&#34;&gt;https://dsunn.github.io/blog/post/clash/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇对上述用iptables来转发局域网流量到clash的方法, 用linux内置的nftables来代替.&lt;/p&gt;
&lt;p&gt;修改/etc/nftables.conf, 在其最后加入下列设置.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;table inet clash
delete table inet clash

table inet clash {
    set local_addr {
        type ipv4_addr
        flags interval
        elements = {
            10.0.0.0/8,
            127.0.0.0/8,
            169.254.0.0/16,
            172.16.0.0/12,
            192.168.0.0/16,
            240.0.0.0/4,
            0.0.0.0/8
        }
    }

    set clashhost_addr {
        type ipv4_addr
        flags interval
        elements = {
            192.168.10.89/32
        }
    }

    chain clash-tproxy {
        ip daddr @local_addr return
        ip saddr @clashhost_addr return
        meta l4proto { tcp, udp } meta mark set 1 tproxy to :7893 accept
    }

    chain clash-mark {
        ip daddr @local_addr return
        ip daddr @clashhost_addr return
        meta mark set 1
    }

    chain mangle-prerouting {
        type filter hook prerouting priority mangle; policy accept;
        meta l4proto { tcp, udp } ct direction original jump clash-tproxy
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在系统上使能nftables&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>Ffmpeg提取字幕文件</title>
      <link>https://dsunn.github.io/blog/post/ffmpeg/</link>
      <pubDate>Mon, 12 Jun 2023 23:07:47 -0400</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/ffmpeg/</guid>
      <description>
        
          
            &lt;p&gt;ffmpeg -i video.mkv -vn -an -codec:s:0 srt subtitle.srt&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>debian LXC搭建modsns</title>
      <link>https://dsunn.github.io/blog/post/mosdns/</link>
      <pubDate>Mon, 05 Jun 2023 09:41:28 -0400</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/mosdns/</guid>
      <description>
        
          
            &lt;p&gt;修改于6/5/2023&lt;/p&gt;
&lt;p&gt;搭建环境: PVE LXC debian 11, 网关clash(科学环境)
项目地址: &lt;a href=&#34;https://github.com/IrineSistiana/mosdns&#34;&gt;https://github.com/IrineSistiana/mosdns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载并copy 二进制文件mosdns到 /usr/bin/
新建目录: /etc/mosdns, 下载并copy一众规则文件到该目录, 配置文件config.yaml也放这里&lt;/p&gt;
&lt;p&gt;关闭systemd-resolved&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;systemctl disable systemd-resolved
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建/etc/systemd/system/mosdns.service&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# /etc/systemd/system/mosdns.service
[Unit]
Description=A DNS forwarder
ConditionFileIsExecutable=/usr/bin/mosdns

[Service]
User=root
StartLimitInterval=5
StartLimitBurst=10
ExecStart=/usr/bin/mosdns &amp;#34;start&amp;#34; &amp;#34;-c&amp;#34; &amp;#34;/etc/mosdns/config.yaml&amp;#34; &amp;#34;-d&amp;#34; &amp;#34;/etc/mosdns&amp;#34;
Restart=always
RestartSec=120
EnvironmentFile=-/etc/sysconfig/mosdns

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开机自启/启动运行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;systemctl enable mosdns
systemctl start mosdns
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我个人的配置文件如下(v5), (不使用fallback, 仅以direct文件分流):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## mosdns v5 conf


log:
  level: debug
  # file: &amp;#34;/etc/mosdns/logs/mosdns.log&amp;#34;
  # production: false


plugins:
  - tag: cache
    type: cache
    args:
      size: 409600
      lazy_cache_ttl: 259200
      dump_file: ./cache.dump
      dump_interval: 600


#规则txt文件 在https://github.com/Loyalsoldier/v2ray-rules-dat下载
  - tag: domain_cn
    type: domain_set
    args:
      exps:                         # 域名表达式。
        - &amp;#39;xn--4gq62f52gdss.com&amp;#39;
        - &amp;#39;mycai.ml&amp;#39;
        # - &amp;#34;google.com&amp;#34;
        # - &amp;#34;regexp:.+\.google\.com$&amp;#34;
      files:                          # 从文件载入
        - &amp;#39;./direct-list.txt&amp;#39;


  - tag: ads
    type: domain_set
    args:
      files:
        - &amp;#39;./oisd_big_domains.txt&amp;#39;   #basic 文件可能better
        - &amp;#39;./reject-list.txt&amp;#39;

  # 转发至本地服务器的插件
  - tag: forward_local
    type: forward
    args:
      concurrent: 1
      upstreams:
        - tag: ros_udp   #ros主路由dns(配置了ISP的v4/6dns和223,114)
          addr: 192.168.10.251
          dial_addr: 192.168.10.251

  # 转发至远程服务器的插件
  - tag: forward_remote
    type: forward
    args:
      concurrent: 1
      upstreams:
        - tag: google_dot
          # addr: &amp;#34;https://dns.google/dns-query&amp;#34;
          addr: &amp;#34;tls://dns.google&amp;#34;
          dial_addr: &amp;#34;8.8.8.8&amp;#34;
          bootstrap: &amp;#34;8.8.8.8&amp;#34;
          idle_timeout: 30
          enable_pipeline: false
          enable_http3: false
          max_conns: 2
          insecure_skip_verify: false
          so_mark: 0
          bind_to_device: &amp;#34;&amp;#34;
        - tag: cf_dot
          # addr: &amp;#39;https://cloudflare-dns.com/dns-query&amp;#39;
          addr: &amp;#39;tls://1.1.1.1:853&amp;#39;
          dial_addr: &amp;#39;1.1.1.1&amp;#39;
          bootstrap: &amp;#34;1.1.1.1&amp;#34;
          idle_timeout: 30
          enable_pipeline: false
          enable_http3: false
          max_conns: 2
          insecure_skip_verify: false
          so_mark: 0
          bind_to_device: &amp;#34;&amp;#34;



  - tag: main
    type: sequence
    args:
      # # ads blocked in adgh, so not here in mosdns
      # - matches:             # 如果
      #     - qname $ads # 如果请求的域名在广告列表内。
      #   exec: reject 3       # 执行 直接返回 NXDOMAIN(3) 屏蔽。
      - exec: $cache      # 然后。查找 cache。
      - matches:             # 如果
          - has_resp         # 有应答了(上一步 cache 找到应答)
        exec: accept         # 结束。
      # 上一步没有找到缓存，就会到这一步，转发至 local/remote 分流 获取应答。
      - matches: 
          - qname $domain_cn
        exec: $forward_local
      - matches: has_resp   #has_wanted_ans / has_resp
        exec: accept
      # - exec: prefer_ipv4
      - exec: $forward_remote
      - exec: accept


  # 启动 udp 和 tcp 服务器。
  - tag: udp_server
    type: udp_server
    args:
      entry: main # 收到的请求会执行上面的逻辑
      listen: :53
  - tag: tcp_server
    type: tcp_server
    args:
      entry: main
      listen: :53
&lt;/code&gt;&lt;/pre&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>Ros通过dhcp6下发ipv6 dns的设定</title>
      <link>https://dsunn.github.io/blog/post/ros_dhcp6/</link>
      <pubDate>Mon, 05 Jun 2023 09:32:08 -0400</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/ros_dhcp6/</guid>
      <description>
        
          
            &lt;p&gt;修改于6/5/2023&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/ipv6 dhcp-server option
 add code=23 name=dns value=0xfd80000000000000ccf2bbfffe0abcf1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外, ros的ipv6-ND中不勾选advertise dns, 勾选other config.&lt;/p&gt;
          
          
        
      </description>
    </item>
    
    <item>
      <title>debian搭建clash的透明代理(Tproxy)(iptables转发)</title>
      <link>https://dsunn.github.io/blog/post/clash/</link>
      <pubDate>Mon, 05 Jun 2023 08:36:36 -0400</pubDate>
      
      <guid>https://dsunn.github.io/blog/post/clash/</guid>
      <description>
        
          
            &lt;p&gt;修改于9/20/2023&lt;/p&gt;
&lt;p&gt;一. clash程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root运行&lt;/li&gt;
&lt;li&gt;下载clash premium (&lt;a href=&#34;https://github.com/Dreamacro/clash/releases/tag/premium&#34;&gt;https://github.com/Dreamacro/clash/releases/tag/premium&lt;/a&gt;) 解压保存为/usr/local/bin/clash&lt;/li&gt;
&lt;li&gt;设置为systemd deamon&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编辑/lib/systemd/system/clash.service&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#/lib/systemd/system/clash.service

Description=A rule based proxy tunnel in Go  
After=network.target  
[Service]  
Type=simple  
Restart=on-abort  
ExecStart=/usr/local/bin/clash  
[Install]  
WantedBy=multi-user.target  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认运行目录为~/.config/clash, config.yaml要存放在工作目录中&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;systemctl daemon-reload  
systemctl enable clash  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;二. 透明代理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启ipv4/ipv6的转发&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo &amp;#34;net.ipv4.ip_forward = 1&amp;#34; &amp;gt;&amp;gt; /etc/sysctl.conf &amp;amp;&amp;amp; sysctl -p  
echo &amp;#34;net.ipv6.conf.all.forwarding = 1&amp;#34; &amp;gt;&amp;gt; /etc/sysctl.conf &amp;amp;&amp;amp; sysctl -p
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关闭systemd-resolved 服务, 让clash dns占有53端口
systemctl disable systemd-resolved&lt;br&gt;
/etc/reslov.conf里我是设置为主路由(ros)的dns&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iptables持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apt install iptables-persistent netfilter-persistent  
netfilter-persistent save  
netfilter-persistent start  
iptables-save  &amp;gt; /etc/iptables/rules.v4  
ip6tables-save  &amp;gt; /etc/iptables/rules.v6  
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;加载恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;iptables-restore  &amp;lt; /etc/iptables/rules.v4  
ip6tables-restore  &amp;lt; /etc/iptables/rules.v6  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;三. iptables
(以下代码中192.168.10.87是我的clash host, 模式为tproxy)&lt;/p&gt;
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
