<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dns on Whatever blog</title>
    <link>https://dsunn.github.io/blog/tags/dns/</link>
    <description>Recent content in Dns on Whatever blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Mar 2024 08:00:07 -0500</lastBuildDate>
    <atom:link href="https://dsunn.github.io/blog/tags/dns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>All about dns</title>
      <link>https://dsunn.github.io/blog/post/all_about_dns/</link>
      <pubDate>Tue, 05 Mar 2024 08:00:07 -0500</pubDate>
      <guid>https://dsunn.github.io/blog/post/all_about_dns/</guid>
      <description>&lt;p&gt;谈谈我的dns在一些特殊的网络架构中的思路&amp;hellip;&#xA;目的:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;走节点的连接, 其dns请求不发到国内的dns服务器&lt;/li&gt;&#xA;&lt;li&gt;减少不必要的dns请求&lt;/li&gt;&#xA;&lt;li&gt;尽量避免所谓的dns leak&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;我的内部网络:&lt;/p&gt;&#xA;&lt;p&gt;主路由 ros, 旁路网关 clash on debain, mosdns server, 交换机, 及各种终端;&#xA;其中clash所在的debian, 网关为ros, 其他设备的网关为clash所在的debian;&#xA;内网到内网的通信基本上会经交换机转发抵达.&lt;/p&gt;&#xA;&lt;p&gt;ros:&lt;/p&gt;&#xA;&lt;p&gt;ros上开启dns服务, 上游为ISP的ipv4和ipv6服务器, 开启Allow Remote Requests, (这条开启是仅仅让mosdns访问的, 后面详解)&#xA;ros通过dhcp_server通知各终端把dns和网关都指向clash及clash_dns, 除clash自己.&lt;/p&gt;&#xA;&lt;p&gt;clash:&lt;/p&gt;&#xA;&lt;p&gt;clash开启dns服务(我用的fake_ip, 当然不用fake_ip也行, 不影响前述目的), clash_dns的唯一上游, 是mosdns; 同时, clash 的 fallback_dns关闭&lt;/p&gt;&#xA;&lt;p&gt;mosdns:&lt;/p&gt;&#xA;&lt;p&gt;mosdns按direct-list(即cn_sites)的域名进行分流, 命中该list的, 请求发到上游ros_dns, ros_dns会向它的上游, 也就是向各ISP_dns请求; 而没有命中该list的, 也就是走节点的, mosdns把请求发给上游8.8.8.8(建议dot/doh); mosdns同样不采用fallback_dns的策略.&lt;/p&gt;&#xA;&lt;p&gt;我们来看一下数据包的路径: mosdns发给ros的请求, 因为都是内网设备, 将直接由交换机转发, 而不经过mosdns的网关, 即clash所在的debian; 而mosdns发给8.8.8.8(我是用dot)的请求, 会按网关要求, 发给clash所在的debian, debian会转发给clash, 由clash加密封装后, 按规则走指定的节点. 当然clash最后也是通过debian的网关, 即ros, 再发到节点.&lt;/p&gt;&#xA;&lt;p&gt;各终端设备:&lt;/p&gt;&#xA;&lt;p&gt;终端设备的dns, 是近观ros dhcp_server的通知, 设置为clash_dns, 而clash_dns_server, 我是设置为fake_ip模式, 当然也可以不设置为fake_ip模式, 后面我会说fake_ip模式的好处.&lt;/p&gt;</description>
    </item>
    <item>
      <title>cloudflare ddns的routeros脚本</title>
      <link>https://dsunn.github.io/blog/post/mikrotik_cf_ddns/</link>
      <pubDate>Tue, 05 Mar 2024 07:33:25 -0500</pubDate>
      <guid>https://dsunn.github.io/blog/post/mikrotik_cf_ddns/</guid>
      <description>&lt;p&gt;在参考了j大佬的&lt;a href=&#34;https://www.digs.eu.org/2024/01/04/ROS%20cloudflare%20DDNS%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC/&#34;&gt;博客&lt;/a&gt;和这位作者的&lt;a href=&#34;https://gist.githubusercontent.com/kolobus/18680f8fb01ce3003cb9a3f82c9d30e1/raw/cf8ecd84fc0e5dccb7298422c7d8c40410c345a3/cf-ddns.rsc&#34;&gt;脚本&lt;/a&gt;的脚本后, 魔改的.&lt;/p&gt;&#xA;&lt;p&gt;适用在cloudflare上更新ipv4和ipv6的动态ip; 和原作者不同的是, 我的脚本是直接从ros接口上取相应ip, 其实我这脚本是放在ppp profile-on up-script中, 在拨号完成后执行一次, 而不是定时反复执行, 故相应修改了代码.&lt;/p&gt;&#xA;&lt;p&gt;token, zone_id, record_id等请先行获取, 获取方法在前述j大佬博客中有所提及.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Cloudflare Dynamic DNS update script&#xA;# Required policy: read, write, test, policy&#xA;# Add this script to scheduler&#xA;# Install DigiCert root CA or disable check-certificate&#xA;# Modified from https://gist.github.com/kolobus/18680f8fb01ce3003cb9a3f82c9d30e1&#xA;# Configuration ---------------------------------------------------------------------&#xA;&#xA;:local TOKEN &amp;#34;&amp;#34;&#xA;&#xA;:local ZONEIDv6 &amp;#34;&amp;#34;&#xA;:local RECORDIDv6 &amp;#34;&amp;#34;&#xA;:local RECORDNAMEv6 &amp;#34;&amp;#34;&#xA;:local IP6NEW&#xA;&#xA;:local ZONEIDv4 &amp;#34;&amp;#34;&#xA;:local RECORDIDv4 &amp;#34;&amp;#34;&#xA;:local RECORDNAMEv4 &amp;#34;&amp;#34;&#xA;:local IP4NEW&#xA;&#xA;:local WANIF &amp;#34;&amp;#34;&#xA;&#xA;#------------------------------------------------------------------------------------&#xA;&#xA;&#xA;&#xA;&#xA;:if ([/interface get $WANIF value-name=running]) do={&#xA;&#xA;    # IPv6 check&#xA;&#xA;    :local &amp;#34;IP6NEW&amp;#34; [/ipv6/address get [:pick [find dynamic global interface=$WANIF] 0 ] address]&#xA;    :set &amp;#34;IP6NEW&amp;#34; [:pick $&amp;#34;IP6NEW&amp;#34; 0 [:find $&amp;#34;IP6NEW&amp;#34; &amp;#34;/&amp;#34;]]&#xA;&#xA;        :local url &amp;#34;https://api.cloudflare.com/client/v4/zones/$ZONEIDv6/dns_records/$RECORDIDv6/&amp;#34;&#xA;&#xA;        :local cfapi [/tool fetch http-method=put mode=https url=$url check-certificate=no output=user as-value \&#xA;            http-header-field=&amp;#34;Authorization: Bearer $TOKEN&amp;#34; \&#xA;            http-data=&amp;#34;{\&amp;#34;type\&amp;#34;:\&amp;#34;AAAA\&amp;#34;,\&amp;#34;name\&amp;#34;:\&amp;#34;$RECORDNAMEv6\&amp;#34;,\&amp;#34;content\&amp;#34;:\&amp;#34;$IP6NEW\&amp;#34;,\&amp;#34;ttl\&amp;#34;:120,\&amp;#34;proxied\&amp;#34;:false}&amp;#34;]&#xA;&#xA;        :log info &amp;#34;CF-DDNS: $RECORDNAMEv6 is now $IP6NEW&amp;#34;&#xA;&#xA;&#xA;   # IPv4 check&#xA;&#xA;    :local ipaddr [/ip address get [/ip address find interface=$WANIF] address]&#xA;    :set IP4NEW [:pick $ipaddr 0 ([len $ipaddr] -3)]&#xA;&#xA;        :local url &amp;#34;https://api.cloudflare.com/client/v4/zones/$ZONEIDv4/dns_records/$RECORDIDv4/&amp;#34;&#xA;&#xA;        :local cfapi [/tool fetch http-method=put mode=https url=$url check-certificate=no output=user as-value \&#xA;            http-header-field=&amp;#34;Authorization: Bearer $TOKEN&amp;#34; \&#xA;            http-data=&amp;#34;{\&amp;#34;type\&amp;#34;:\&amp;#34;A\&amp;#34;,\&amp;#34;name\&amp;#34;:\&amp;#34;$RECORDNAMEv4\&amp;#34;,\&amp;#34;content\&amp;#34;:\&amp;#34;$IP4NEW\&amp;#34;,\&amp;#34;ttl\&amp;#34;:120,\&amp;#34;proxied\&amp;#34;:false}&amp;#34;]&#xA;&#xA;        :log info &amp;#34;CF-DDNS: $RECORDNAMEv4 is now $IP4NEW&amp;#34;&#xA;&#xA;&#xA;} else={&#xA;&#xA;    :log info &amp;#34;CF-DDNS: $WANIF is not currently running, quitting&amp;#34;&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>debian LXC搭建modsns</title>
      <link>https://dsunn.github.io/blog/post/mosdns/</link>
      <pubDate>Mon, 05 Jun 2023 09:41:28 -0400</pubDate>
      <guid>https://dsunn.github.io/blog/post/mosdns/</guid>
      <description>&lt;p&gt;修改于6/5/2023&lt;/p&gt;&#xA;&lt;p&gt;搭建环境: PVE LXC debian 11, 网关clash(科学环境)&#xA;项目地址: &lt;a href=&#34;https://github.com/IrineSistiana/mosdns&#34;&gt;https://github.com/IrineSistiana/mosdns&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;下载并copy 二进制文件mosdns到 /usr/bin/&#xA;新建目录: /etc/mosdns, 下载并copy一众规则文件到该目录, 配置文件config.yaml也放这里&lt;/p&gt;&#xA;&lt;p&gt;关闭systemd-resolved&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;systemctl disable systemd-resolved&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新建/etc/systemd/system/mosdns.service&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# /etc/systemd/system/mosdns.service&#xA;[Unit]&#xA;Description=A DNS forwarder&#xA;ConditionFileIsExecutable=/usr/bin/mosdns&#xA;&#xA;[Service]&#xA;User=root&#xA;StartLimitInterval=5&#xA;StartLimitBurst=10&#xA;ExecStart=/usr/bin/mosdns &amp;#34;start&amp;#34; &amp;#34;-c&amp;#34; &amp;#34;/etc/mosdns/config.yaml&amp;#34; &amp;#34;-d&amp;#34; &amp;#34;/etc/mosdns&amp;#34;&#xA;Restart=always&#xA;RestartSec=120&#xA;EnvironmentFile=-/etc/sysconfig/mosdns&#xA;&#xA;[Install]&#xA;WantedBy=multi-user.target&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开机自启/启动运行&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;systemctl enable mosdns&#xA;systemctl start mosdns&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我个人的配置文件如下(v5), (不使用fallback, 仅以direct文件分流):&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## mosdns v5 conf&#xA;&#xA;&#xA;log:&#xA;  level: debug&#xA;  # file: &amp;#34;/etc/mosdns/logs/mosdns.log&amp;#34;&#xA;  # production: false&#xA;&#xA;&#xA;plugins:&#xA;  - tag: cache&#xA;    type: cache&#xA;    args:&#xA;      size: 409600&#xA;      lazy_cache_ttl: 259200&#xA;      dump_file: ./cache.dump&#xA;      dump_interval: 600&#xA;&#xA;&#xA;#规则txt文件 在https://github.com/Loyalsoldier/v2ray-rules-dat下载&#xA;  - tag: domain_cn&#xA;    type: domain_set&#xA;    args:&#xA;      exps:                         # 域名表达式。&#xA;        - &amp;#39;xn--4gq62f52gdss.com&amp;#39;&#xA;        - &amp;#39;mycai.ml&amp;#39;&#xA;        # - &amp;#34;google.com&amp;#34;&#xA;        # - &amp;#34;regexp:.+\.google\.com$&amp;#34;&#xA;      files:                          # 从文件载入&#xA;        - &amp;#39;./direct-list.txt&amp;#39;&#xA;&#xA;&#xA;  - tag: ads&#xA;    type: domain_set&#xA;    args:&#xA;      files:&#xA;        - &amp;#39;./oisd_big_domains.txt&amp;#39;   #basic 文件可能better&#xA;        - &amp;#39;./reject-list.txt&amp;#39;&#xA;&#xA;  # 转发至本地服务器的插件&#xA;  - tag: forward_local&#xA;    type: forward&#xA;    args:&#xA;      concurrent: 1&#xA;      upstreams:&#xA;        - tag: ros_udp   #ros主路由dns(配置了ISP的v4/6dns和223,114)&#xA;          addr: 192.168.10.251&#xA;          dial_addr: 192.168.10.251&#xA;&#xA;  # 转发至远程服务器的插件&#xA;  - tag: forward_remote&#xA;    type: forward&#xA;    args:&#xA;      concurrent: 1&#xA;      upstreams:&#xA;        - tag: google_dot&#xA;          # addr: &amp;#34;https://dns.google/dns-query&amp;#34;&#xA;          addr: &amp;#34;tls://dns.google&amp;#34;&#xA;          dial_addr: &amp;#34;8.8.8.8&amp;#34;&#xA;          bootstrap: &amp;#34;8.8.8.8&amp;#34;&#xA;          idle_timeout: 30&#xA;          enable_pipeline: false&#xA;          enable_http3: false&#xA;          max_conns: 2&#xA;          insecure_skip_verify: false&#xA;          so_mark: 0&#xA;          bind_to_device: &amp;#34;&amp;#34;&#xA;        - tag: cf_dot&#xA;          # addr: &amp;#39;https://cloudflare-dns.com/dns-query&amp;#39;&#xA;          addr: &amp;#39;tls://1.1.1.1:853&amp;#39;&#xA;          dial_addr: &amp;#39;1.1.1.1&amp;#39;&#xA;          bootstrap: &amp;#34;1.1.1.1&amp;#34;&#xA;          idle_timeout: 30&#xA;          enable_pipeline: false&#xA;          enable_http3: false&#xA;          max_conns: 2&#xA;          insecure_skip_verify: false&#xA;          so_mark: 0&#xA;          bind_to_device: &amp;#34;&amp;#34;&#xA;&#xA;&#xA;&#xA;  - tag: main&#xA;    type: sequence&#xA;    args:&#xA;      # # ads blocked in adgh, so not here in mosdns&#xA;      # - matches:             # 如果&#xA;      #     - qname $ads # 如果请求的域名在广告列表内。&#xA;      #   exec: reject 3       # 执行 直接返回 NXDOMAIN(3) 屏蔽。&#xA;      - exec: $cache      # 然后。查找 cache。&#xA;      - matches:             # 如果&#xA;          - has_resp         # 有应答了(上一步 cache 找到应答)&#xA;        exec: accept         # 结束。&#xA;      # 上一步没有找到缓存，就会到这一步，转发至 local/remote 分流 获取应答。&#xA;      - matches: &#xA;          - qname $domain_cn&#xA;        exec: $forward_local&#xA;      - matches: has_resp   #has_wanted_ans / has_resp&#xA;        exec: accept&#xA;      # - exec: prefer_ipv4&#xA;      - exec: $forward_remote&#xA;      - exec: accept&#xA;&#xA;&#xA;  # 启动 udp 和 tcp 服务器。&#xA;  - tag: udp_server&#xA;    type: udp_server&#xA;    args:&#xA;      entry: main # 收到的请求会执行上面的逻辑&#xA;      listen: :53&#xA;  - tag: tcp_server&#xA;    type: tcp_server&#xA;    args:&#xA;      entry: main&#xA;      listen: :53&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Ros通过dhcp6下发ipv6 dns的设定</title>
      <link>https://dsunn.github.io/blog/post/ros_dhcp6/</link>
      <pubDate>Mon, 05 Jun 2023 09:32:08 -0400</pubDate>
      <guid>https://dsunn.github.io/blog/post/ros_dhcp6/</guid>
      <description>&lt;p&gt;修改于6/5/2023&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/ipv6 dhcp-server option&#xA; add code=23 name=dns value=0xfd80000000000000ccf2bbfffe0abcf1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外, ros的ipv6-ND中不勾选advertise dns, 勾选other config.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
